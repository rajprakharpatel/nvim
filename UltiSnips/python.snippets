snippet name "if __name__ == '__main__'" b
if __name__ == '__main__':
  
endsnippet

snippet for_ "input test cases"
for _ in range(int(input())):
	
endsnippet

snippet mapi "list of integers"
$1 = list(map(int, input().split()))
endsnippet

snippet compi "compitetive coding template"
import sys
import math
import cmath
import time
import collections
start_time = time.time()


def solve():
	n = in_n()
	k, l = inp_nums()
	ls = inp_ls()
	$1

def main():
    global tt
    if not ONLINE_JUDGE:
        sys.stdin = open("inp", "r")
        sys.stdout = open("out", "w+")
    for _ in range(in_n()):
        solve()
    if not ONLINE_JUDGE:
        print("Time Elapsed :", time.time() - start_time, "seconds")
        sys.stdout.close()


def in_n():
    return(int(input()))


def inp_ls():
    return(list(map(int, input().split())))


def inp_nums():
    return(input().strip())


def invr():
    return(map(int, input().split()))


def out_str(s):
    sys.stdout.write(s + "\n")


def out_int(n):
    sys.stdout.write(str(n) + "\n")


def out_ls(ls):
    sys.stdout.write(" ".join(map(str, ls)) + "\n")

# UTILITY FUNCTIONS


def counter(a):
    q = [0] * max(a)
    for i in range(len(a)):
        q[a[i] - 1] = q[a[i] - 1] + 1
    return(q)


def counter_elements(a):
    q = dict()
    for i in range(len(a)):
        if a[i] not in q:
            q[a[i]] = 0
        q[a[i]] = q[a[i]] + 1
    return(q)


def string_counter(a):
    q = [0] * 26
    for i in range(len(a)):
        q[ord(a[i]) - 97] = q[ord(a[i]) - 97] + 1
    return(q)


def factorial(n, m=1000000007):
    q = 1
    for i in range(n):
        q = (q * (i + 1)) % m
    return(q)


def factors(n):
    q = []
    for i in range(1, int(n ** 0.5) + 1):
        if n % i == 0:
            q.append(i)
            q.append(n // i)
    return(list(sorted(list(set(q)))))


def prime_factors(n):
    q = []
    while n % 2 == 0:
        q.append(2)
        n = n // 2
    for i in range(3, int(n ** 0.5) + 1, 2):
        while n % i == 0:
            q.append(i)
            n = n // i
    if n > 2:
        q.append(n)
    return(list(sorted(q)))


def transpose(a):
    n, m = len(a), len(a[0])
    b = [[0] * n for i in range(m)]
    for i in range(m):
        for j in range(n):
            b[i][j] = a[j][i]
    return(b)


def power_two(x):
    return (x and (not(x & (x - 1))))


def ceil(a, b):
    return -(-a // b)


def seive(n):
    a = [1]
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] is True):
            for i in range(p ** 2, n + 1, p):
                prime[i] = False
        p = p + 1
    for p in range(2, n + 1):
        if prime[p]:
            a.append(p)
    return(a)


#  ONLINE_JUDGE = __debug__
ONLINE_JUDGE = 0
if ONLINE_JUDGE:
    import io
    import os
    input = io.BytesIO(os.read(0, os.fstat(0).st_size)).readline
    # input = sys.stdin.readline

main()
endsnippet
